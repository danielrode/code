#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Author: Daniel Rode
# Name: File History Git
# Tags: file management, backup, history
# Dependencies:
#   git
#   lf
# Created: 25 Mar 2025
# Updated: 01 Apr 2025


# Description: Given some file path, assuming the file is part of a git
# repository, create a read-only cache of all committed revisions of said
# file as a temporary filesystem directory and open that directory in a
# file manager (lf).


import sys
import subprocess as sp
from pathlib import Path
from tempfile import TemporaryDirectory

from collections.abc import Iterable


# Constants
EXE_NAME = sys.argv[0].split('/')[-1]  # This script's filename
HELP_TEXT = f"Usage: {EXE_NAME}  GIT_FILE_PATH"


# Functions
def print2(*args, **kwargs) -> None:
    print(*args, **kwargs, file=sys.stderr)

def run_iter(cmd: list[str]) -> Iterable:
    """
    Run a system executable and yield its output line-by-line, as output
    is generated.
    """
    # Start process
    process = sp.Popen(
        cmd,
        stdout=sp.PIPE,
        stderr=sp.PIPE,
        text=True,
        bufsize=1,  # Line-buffered output
    )

    # Yield process output as lines, as the lines are produced
    for line in process.stdout:
        yield line.rstrip()

    # If process failed, abort
    return_code = process.wait()
    if return_code != 0:
        print2(process.stderr.read(), end='')
        raise sp.CalledProcessError(return_code, cmd)

def lines2blocks(lines: Iterable) -> Iterable:
    """
    Iterate over a set of lines, adding each one to a queue, and each time an
    empty line is encountered, yield the queue as a list.
    """
    block = []
    for l in lines:
        l = l.rstrip()
        if not l:
            yield block
            block = []
        else:
            block += [l]


# Process command line arguments
try:
    fpath = Path(sys.argv[1])
except IndexError:
    print2(HELP_TEXT)
    sys.exit(1)

if not fpath.is_file():
    print2("error: File not found:", fpath)
    exit(1)

# Process stdout lines as they are generated
git_hist = run_iter((
    'git', 'log',
    '--follow',  # Account for file renames
    '--name-only',
    '--pretty=format:%H %cd',
    '--date=format:%Y-%m-%d_%H:%M',
    '--', str(fpath),
))
with TemporaryDirectory() as tmpdir:
    # Write each committed revision of file to a temp file with the commit date
    # as the name
    for line1, line2 in lines2blocks(git_hist):
        commit, date = line1.split(' ')
        fpath = line2
        cmd = ('git', 'show', f"{commit}:{fpath}")
        p = sp.run(cmd, text=True, check=True, capture_output=True)
        tmpf = Path(tmpdir, date)
        with tmpf.open('w') as f:
            f.write(p.stdout)

    # Open file manager to temp directory where the cached file versions are
    sp.run(['lf', tmpdir], check=True)
